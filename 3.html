<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Реляционная модель.</title>

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/db/css/main.css">
	<link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,900,400italic%7CSignika:700,300,400,600' rel='stylesheet' type='text/css'>

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/db">Главная</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	  
	    
	  
	    
	  

    <!-- Nav links -->
	  <a href="https://github.com/korolr">Загрузка</a>
<a href="https://github.com/korolr">Проект на  Github</a>


	</div>

  <!-- Nav footer -->
	
	  <footer>

	<span>Версия 1.1.0</span>

</footer>

	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header">
	<a href="/db">
		<img src="/db/img/emerald.svg" alt="Emerald Logo">
	  <h1>Основы проектирования бд</h1>
	</a>
</header>

      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<article id="post-page">
	<h2>Реляционная модель.</h2>		
	<time datetime="2015-02-15T00:00:00+04:00" class="by-line">15 Feb 2015</time>
	<div class="content">

		<p>Реляционная модель.</p>

<ul>
  <li>.Таблица = отношение.</li>
  <li>.Названия столбцов = атрибуты.</li>
  <li>
    <p>.Строка = кортеж</p>

    <p>Beers</p>
  </li>
</ul>

<p>name   manf</p>

<p>WinterBrew     Pete's</p>

<p>BudLite           A.B.</p>

<p>…   …</p>

<ul>
  <li>.Схема отношения = имена столбцов (атрибуты) + другая информация о структуре, например, ключи, другие ограничения.
Например: Beers (name, manf).</li>
  <li>
    <p>.Порядок атрибутов произволен, но на практике используется порядок, указанный в схеме отношения.</p>
  </li>
  <li>
    <p>.Экземпляр отношения (таблица) – текущий набор строк для схемы отношения.</p>
  </li>
  <li>.Схема базы данных = множество схем отношений.</li>
</ul>

<p>Почему таблицы (отношения)?</p>

<ul>
  <li>.Очень простая модель.</li>
  <li>.Часто совпадает с нашим представлением о данных.</li>
  <li>
    <p>.Абстрактная модель, которая лежит в основе SQL, наиболее используемого сегодня языка в СУБД.</p>
  </li>
  <li>.В абстрактной реляционной модели используется понятие «множество»,  а в SQL – «набор» или множество с повторениями.</li>
</ul>

<p>Проектирование реляционной модели.</p>

<p>Самый простой подход (но не всегда лучший): преобразовать каждое множество сущностей и каждую связь в таблицу (отношение).</p>

<p>Множество сущностей  -&gt; Отношение</p>

<p>Атрибуты объекта станут реляционными атрибутами.</p>

<h6 id="beers">Beers</h6>

<p>Преобразуется в : Beers (name, manf).</p>

<p>E/R Связи -&gt; Oтношения.</p>

<p>Таблица имеет столбец для каждого атрибута-ключа множества сущностей,  участвующего в связи.</p>

<ul>
  <li>.Добавить  атрибуты, которые принадлежат связи непосредственно.</li>
  <li>.Можно переименовать столбцы.</li>
  <li>.Существенно, для множественных ролей объектов.</li>
</ul>

<h6 id="beers-1">Beers</h6>

<h6 id="drinkers">Drinkers</h6>

<p>husband                      wife</p>

<p>Likes (drinker, beer)</p>

<p>Favorite (drinker, beer)</p>

<p>Buddies (name1, name2)</p>

<p>Married (husband, wife)</p>

<p>Объединение таблиц (отношений).</p>

<p>Иногда это имеет смысл объединять отношения.</p>

<ul>
  <li>.В общем случае: Отношение для некоторого объекта E плюс отношение для некоторой связи "многие-к-одному" объекта E и другого объекта.</li>
</ul>

<p>Например:</p>

<p>Еслиобъединить Drinker (name, addr)  с</p>

<p>Favorite (drinker, beer), тополучим</p>

<p>Drinker1(name, addr, favBeer).</p>

<ul>
  <li>
    <p>.Объединение отношений может привести к избыточности.</p>
  </li>
  <li>
    <p>.Например, объединение Drinker  с  Likes приведет к дублированию addr, т.е.:</p>
  </li>
</ul>

<p>Name addr  beer</p>

<h1 id="sally-----123-maple-----------bud">Sally     123 Maple           Bud</h1>

<p>Sally     123 Maple    Miller</p>

<ul>
  <li>.Обратите внимание на отличие: Favorite – это связь "многие-к-одному ", а  Likes  - "многие-ко-многим ".</li>
</ul>

<p>Слабые множества, Связи -&gt; Отношения.</p>

<ul>
  <li>
    <p>.Отношение для слабого объекта должно включать полный ключ (то есть, атрибуты связанных объектов) наряду с собственными атрибутами.</p>
  </li>
  <li>
    <p>.Такая поддерживающая связь (двойной ромб) производит отношение, которое является фактически избыточным и которое должно быть удалено из структуры базы данных</p>
  </li>
</ul>

<p>Например:</p>

<h6 id="hosts">Hosts</h6>

<p>Hosts (hostName)</p>

<p>Logins (loginName, hostName)</p>

<p>At (loginName, hostname, hostName2)</p>

<ul>
  <li>
    <p>.В отношении AthostName и hostName2 определяют один и тот же компьютер, поэтому можно удалить один из них.</p>
  </li>
  <li>
    <p>.Затем, отношения Logins и At становятся одинаковыми, поэтому можно удалить одно из них.</p>
  </li>
  <li>
    <p>.В этом случае, схема для Hosts – подмножество схемы для Logins. Удалить Hosts?</p>
  </li>
</ul>

<p><strong>Подклассы</strong>** -&gt; <strong>**Отношения.</strong></p>

<p>Подходы:</p>

<ol>
  <li>E/R модель: сущность распределена по набору классов, связанных посредством isa. Создается по одному отношению для каждой сущности.</li>
</ol>

<ul>
  <li>
    <p>.Сущность представляется в отношениях  каждого подкласса,  которому она принадлежит.</p>
  </li>
  <li>
    <p>.Отношение имеет только присоединенные атрибуты объекта + ключ.</p>
  </li>
</ul>

<ol>
  <li>Использование NULL (пустых значений). Создается одно соотношение для корневого класса или корневого объекта, со всеми атрибутами, присутствующими в каком-либо подклассе.</li>
</ol>

<ul>
  <li>.Поместить NULL (пустое значение) в атрибутах, не относящихся к данному объекту.</li>
</ul>

<p>Например:</p>

<h6 id="beers-2">Beers</h6>

<h6 id="ales">Ales</h6>

<p>E/R модель:</p>

<p>name   manf</p>

<p>Bud              A.B.</p>

<p>SummerBrew   Pete's</p>

<p>Beers</p>

<p>name   color</p>

<p>SummerBrew          dark</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   Ales
</code></pre>
</div>

<p>Использование Null (пустыхзначений):</p>

<p>name   manf  color</p>

<p>Bud                   A.B.           NULL</p>

<h1 id="summerbrew-----------petes---------dark">SummerBrew           Pete's         dark</h1>

<p>Beers</p>

<p>Функциональные зависимости.</p>

<p>X -&gt; A = утверждению относительно отношения R, если два кортежа имеют одинаковые значения атрибутов X, то они должны также иметь и одинаковые значения атрибута A.</p>

<p>Например:</p>

<p>Drinkers ( name, addr, beersLiked, manf, favoriteBeer)</p>

<p>name   addr     beersLiked  manf  favoriteBeer</p>

<p>Janeway    Voyager       Bud                      A.B.       WickedAle</p>

<p>Janeway    Voyager       WickedAle           Pete's     WickedAle</p>

<p>Spock        Enterprise    Bud                      A.B.        Bud</p>

<ul>
  <li>.Можно утверждать, что:</li>
</ul>

<ol>
  <li>
    <p>name -&gt; addr</p>
  </li>
  <li>
    <p>name -&gt; favoriteBeer</p>
  </li>
  <li>
    <p>beersLiked -&gt; manf</p>
  </li>
</ol>

<ul>
  <li>.Укороченная запись: объединение ФЗ с общей левой стороной объеденяет их правые стороны.</li>
  <li>.Иногда несколько атрибутов вместе определяют какой-нибудь атрибут, хотя каждый из них не делает этого.</li>
</ul>

<p>Например: beer bar-&gt; price</p>

<p>Ключи отношений.</p>

<p>K - ключ для отношения R если:</p>

<ol>
  <li>
    <p>K -&gt; все атрибуты R.</p>
  </li>
  <li>
    <p>Не существует никакого строгого подмножества K, удовлетворяющего (1).</p>
  </li>
</ol>

<ul>
  <li>.Если K по крайней мере удовлетворяет (1), то K – суперключ.</li>
</ul>

<p>Соглашения.</p>

<ul>
  <li>
    <p>.Выбирается один ключ; атрибуты ключа подчеркиваются в схеме отношения.</p>
  </li>
  <li>
    <p>.Символом X,Y,Z и т.д. ,будем обозначать множества атрибутов; A,B,C и т.д.- отдельный атрибут.</p>
  </li>
  <li>
    <p>.ABC вместо {A, B, C} в ФЗ.</p>
  </li>
</ul>

<p>Пример.</p>

<p>Drinkers ( name, addr, beersLiked, manf, favoriteBeer)</p>

<ul>
  <li>.{name,  beersLiked } -&gt; все остальные атрибуты.</li>
  <li>
    <p>.{ name,  beersLiked } – суперключ.</p>
  </li>
  <li>.name -&gt; beersLiked – не имеет места, поэтому name – не суперключ.</li>
  <li>.beersLiked -&gt; name – также не имеет места, поэтому предпочтения – не суперключ.</li>
  <li>.Т.о. { name,  beersLiked } – ключ.</li>
  <li>.Нет никакого другого ключа в этом примере.</li>
  <li>
    <p>.Ни name ни beersLiked не могут находиться в правой стороне ФЗ, поэтому они являются частью любого суперключа.</p>
  </li>
  <li>.Важно: понятие «ключ» связано с кортежем, а не с объектом.  Если объект представлен несколькими кортежами, то ключ объекта не то же самое, что ключ отношения.</li>
</ul>

<p>Кто определяет ключи/функциональные зависимости?</p>

<ul>
  <li>.Можно определить, что K - ключ.</li>
  <li>.Затем вывести функциональные зависимости – что</li>
</ul>

<p>K -&gt; А для каждого атрибута A.</p>

<ul>
  <li>
    <p>.Не удивительно: K будет являться ключом, только если существуют такие ФЗ, согласно формальному определению ключа.</p>
  </li>
  <li>
    <p>.Или, можно установить некоторые ФЗ и определить один или  несколько ключей по формальным правилам.</p>
  </li>
  <li>
    <p>.Диаграмма «сущность-связь» определяет ФЗ путем указания ключей и связей «многие-к-одному».</p>
  </li>
  <li>.Правило для руководства: любая ФЗ выводится из свойств ключа, связи «многие-к-одному» или здравого смысла .</li>
  <li>.Например, "Нет двух предметов, которые проводятся в одной и той же аудитории в одно и то же  время "  влечет</li>
</ul>

<p>аудитория время -&gt; предмет.</p>

<p>Вывод функциональных зависимостей.</p>

<p>Это важно потому что…</p>

<ul>
  <li>.Если мы пытаемся  улучшить реляционную модель данных, то часто задаемся вопросом "Должна ли эта ФЗ присутствовать в этом отношении? "</li>
</ul>

<p>Если существуют ФЗ Х1 -&gt; A1, X2 -&gt; A2, … Xn -&gt; An, будет ли необходимо выполняться ФЗ Y -&gt; B  в том же самом отношении?</p>

<ul>
  <li>.Начнем с предположения, что 2 кортежа имеют одинаковое значение Y. Используем данные ФЗ чтобы вывести другие атрибуты с одинаковыми значениямию. Если  B  среди них то имеет место Y -&gt; B .</li>
</ul>

<p>Алгоритм.</p>

<p>Пусть Y+= замыкание Y = множество атрибутов функционально зависимых от Y :</p>

<ul>
  <li>.Первоначально: Y+:= Y .</li>
  <li>
    <p>.Индукция: Если X  Y+ и  X -&gt; A – функциональная зависимость, то A добавляется к Y+.</p>
  </li>
  <li>.Конец, если Y+ не изменяется.</li>
</ul>

<p><strong>Пример</strong><strong>.</strong></p>

<p>A -&gt; B, BC -&gt; D.</p>

<ul>
  <li>
    <p>.A+= AB.</p>
  </li>
  <li>
    <p>.C+= C.</p>
  </li>
  <li>
    <p>.(AC)+= ABCD.</p>
  </li>
</ul>

<p>Нахождение всех возможных функциональных зависимостей.</p>

<p>Зачем это делается: Предположим, что есть отношение ABCD с некоторой функциональной зависимостью F. Если мы решаем разбить ABCD на ABC и AD, что будет ФЗ для ABC и AD?</p>

<ul>
  <li>.Например: F = AB -&gt; C, C -&gt; D, D -&gt; A.</li>
</ul>

<p>Подходит только AB  -&gt; C  для ABC, но фактически C -&gt; A следует из F и может быть применено к отношению ABC.</p>

<ul>
  <li>.Сложность задачи растет экспоненциально с ростом числа атрибутов.</li>
</ul>

<p>Алгоритм.</p>

<ul>
  <li>
    <p>.Для каждого множества атрибутов Х определить Х+.</p>
  </li>
  <li>
    <p>.Исключая Х= и Х=все атрибуты.</p>
  </li>
  <li>
    <p>.Добавить X -&gt; A для каждого A  из  X+ - X.</p>
  </li>
  <li>
    <p>.Удалить XY -&gt; A, если есть X -&gt; A.</p>
  </li>
  <li>
    <p>.Спроектировать ФЗ – выбрать те ФЗ, которые включают только атрибуты проекции.</p>
  </li>
  <li>
    <p>.Обратите внимание, что после того, как мы спроектируем ФЗ на некоторое отношение, удаленные ФЗ могут быть выведены из этого отношения.</p>
  </li>
</ul>

<p><strong>Пример</strong><strong>.</strong></p>

<p>Для отношения ABC  с ФЗ: A -&gt; B, B -&gt; C, спроектировать ФЗ  на AC.</p>

<ol>
  <li>
    <p>A+= ABC;  дает A -&gt; B, A -&gt; C.</p>
  </li>
  <li>
    <p>B+= BC;  дает  B -&gt; C.</p>
  </li>
  <li>
    <p>AB+= ABC; дает AB -&gt; C; опускаем в пользу A -&gt; C.</p>
  </li>
  <li>
    <p>AC+= ABC дает AC -&gt; B; опускаем в пользу  A -&gt; B.</p>
  </li>
  <li>
    <p>C+= C  и  BC+= BC;  ничего не добавляет.</p>
  </li>
</ol>

<ul>
  <li>
    <p>.В результате имеем  FD's: A -&gt; B, A -&gt; C, B -&gt; C.</p>
  </li>
  <li>
    <p>.Проекция на AC: A -&gt; C.</p>
  </li>
</ul>

		
	</div>
</article>



	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer><span>@2017 - Пктим</span></footer>


	    <!-- Script -->
      <script src="/db/js/main.js"></script>	


	</div>
</body>
</html>
