---
title: Объединение, пересечение, разность.


---
Объединение, пересечение, разность.

«(подзапрос) UNION (подзапрос)» выполняет объединение двух отношений.

- .Аналогично

INTERSECT = пересечению,

EXCEPT = разности.

- .Но в Oracle разность - MINUS, не EXCEPT.

**Пример.** Найти посетителей и сорта пива такие, что посетитель предпочитает данный сорт и часто посещает бар, который имеет в продаже этот сорт.

Likes(drinker, beer)

Sells(bar, beer, price)

Frequents(drinker, bar)

( SELECT \* FROM Likes )

INTERSECT

( SELECT drinker, beer

  FROM Sells, Frequents

  WHERE Frequents.bar = Sells.bar

);

Обеспечение семантики набор/множество.

- .Значение по умолчанию для «SELECT-FROM-WHERE» - набор, значение по умолчанию для объединения, пересечения и разности - множество.

- .Почему? Экономится время, поскольку при генерации кортежи не сравниваются .

- .Но необходима сортировка когда выполняется пересечение или (Объединение также отнесено в эту группу)

- .Семантика множества обеспечивается указанием режима DISTINCT после SELECT.

- .Убедитесь, что затраты времени оправданы.

**Пример.** Найти все различные цены на пиво.

Sells(bar, beer, price)

SELECT DISTINCT price

FROM Sells;

- .Семантика набора обеспечивается указанием режима ALL после UNION, INTERSECT, EXCEPT.



Выражения, содержащие соединение (Join).

Существует несколько видов таких выражений.

- .Может использоваться самостоятельно (в «SELECT-FROM-WHERE») или использоваться для определения отношения в опции FROM.

     R CROSS JOIN S

R JOIN S ON условие (например, условие: R.B = S.B)

R NATURAL JOIN S

R OUTER JOIN S

- .Внешнее объединение имеет несколько способов записи:

1. Необязательное NATURAL в начале.

2. Необязательное ON условие в конце.

3. Необязательные LEFT, RIGHT или FULL (по умолчанию)  перед OUTER.

- .LEFT = выбирает (включая NULL) «висящие» кортежи только из R, RIGHT = только из S.

Агрегирование.

Sum, avg, min, max, and count применяются к атрибутам/столбцам.

- .Используются в списке, следующем за SELECT.

**Пример.** Найти среднюю цену сорта Bud.

Sells(bar, beer, price)

SELECTAVG(price)

FROMSells

WHEREbeer = &#39;Bud&#39;;

- .Каждый кортеж участвует в расчетах один раз (предварительно суммируются цены во всех барах, торгующих сортом Bud).

Задание:

Что делать, если  Sells - множество?



Удаление дубликатов перед агрегированием.

Найти количество различных цен, по которым продается сорт Bud.

Sells(bar, beer, price)

SELECT COUNT(DISTINCT price)

FROM Sells

WHERE beer = &#39;Bud&#39;;

- .DISTINCT может использоваться с любой функцией агрегирования, но обычно эта опция используется в сочетании с COUNT.

Группировка.

GROUP BY следует за  конструкцией «SELECT-FROM-WHERE» и имеет список атрибутов.

- .Результат – это отношение, удовлетворяющее условиям в опциях FROM и WHERE и сгруппированное по значениям этих атрибутов, функции агрегирования применяются только внутри группы.

**Пример.** Найти среднюю цену, по которой продается каждый сорт.

Sells(bar, beer, price)

SELECT beer, AVG(price)

FROM Sells

GROUP BY beer;

**Пример.** Найти, для каждого посетителя, среднюю цену сорта Bud в тех барах, где эти посетители являются постоянными посетителями.

Sells(bar, beer, price)

Frequents(drinker, bar)

SELECT drinker, AVG(price)

# FROM Frequents, Sells

WHERE beer = &#39;Bud&#39;

AND Frequents.bar = Sells.bar

GROUP BY drinker;

- .Замечание: группировка выполняется после операций  x и .



**Ограничения на использование функций агрегирования в SELECT.**

Если используется любая из функций агрегирования, то каждый элемент списка SELECT должен либо аггрегированным значением, либо присутствовать в опции GROUP BY.

**Пример.** Следующий пример мог бы дать ответ на вопрос: найти бар с самым дешевым сортом пива Bud:

Sells(bar, beer, price)

SELECTbar, MIN(price)

FROMSells

WHEREbeer = &#39;Bud&#39;;

- .Но это недопустимо в SQL.

Задание: Как найти такой бар?

















Опция HAVING.

- .Опция HAVING – это выбор из групп, тогда как опция WHERE – выбор из кортежей.
- .Условие может использовать переменные-кортежи или отношения из опции FROM и их атрибуты, точно так же как и опция WHERE.

- .Диапазоном является только группа.

- .Атрибуты лучше выбирать из групп; то есть, они должны присутствовать среди атрибутов GROUP BY.



Пример.

Найти среднюю цену тех сортов пива, которые либо продаются в барах с количеством продаваемых сортов &gt;= 3, либо произведены Anheuser-Busch.

Beers(name, manf)

Sells(bar, beer, price)

SELECT beer, AVG(price)

# FROM Sells

GROUP BY beer

HAVING COUNT(\*) &gt;= 3

OR beer IN (  SELECT name

              FROM Beers

              WHERE manf = &#39;Anheuser-Busch&#39;

           );







# Модификация баз данных.

Модификация = добавление (insert) + удаление (delete) + обновление (update).

Добавление(вставка) кортежа.

INSERT INTO отношение VALUES (список значений).

- .Добавление кортежа = список значений, значения должны соответствовать атрибутам в том порядке, в котором они объявлены в структуре.

- .Забыли порядок? Перечислите атрибуты в скобках как аргументы отношения.

**Пример****.** Likes(drinker, beer). Добавить информацию о том, что  Sally предпочитает Bud.

INSERTINTOLikes(drinker, beer)

VALUES(&#39;Sally&#39;, &#39;Bud&#39;);

# Добавление результата запроса.

INSERT INTO отношение (подзапрос).

Пример:Создать таблицу для всех возможных друзей Sally, т.е. людей, которые являются частыми посетителями баров, в которых частым посетителем является и Sally. Frequents(drinker, bar)

CREATE TABLE PotBuddies( name char(30));

INSERT INTO PotBuddies

(SELECT DISTINCT d2.drinker

FROM Frequents d1, Frequents d2

WHERE d1.drinker = &#39;Sally&#39;

AND d2.drinker &lt;&gt; &#39;Sally&#39; AND d1.bar = d2.bar

);

Удаление.

DELETE FROM отношение WHERE условие.

- .Удаляет все кортежи, удовлетворяющие условию, из указанного отношения.

**Пример 1.** Sally больше не предпочитает Bud. Likes(drinker, beer)

DELETEFROMLikes

WHEREdrinker = &#39;Sally&#39; ANDbeer = &#39;Bud&#39;;

**Пример 2:** Удалить все кортежи из отношения Likes.

DELETE FROM Likes;

**Пример 3.** Удалить сорта пива, у производителя которых есть еще один сорт. Beers(name, manf)

DELETE FROM Beers b

WHERE EXISTS ( SELECT name

                       FROM Beers

                       WHERE manf = b.manf

                       AND name &lt;&gt; b.name

                    );

- .Замечание: для отношения, из которого удаляется информация, используется переменная-кортеж.

- .Семантика не очевидна. IfA.B. производит только Bud и BudLite , будет ли BudLite удовлетворять условию после удаления Bud?

- .Семантика SQL: условия модификации для всех кортежей проверяются системой до начала выполнения команды модификации.

- .В примере Bud/Budlite, мы сначала проверим все кортежи и пометим оба сорта пива, как подлежащие модификации, а затем оба удалим.

# Обновление.

UPDATE отношение

SET список значений

WHERE условие.

**Пример 1.** Изменить номер телефона посетителя Fred  на значение 555-1212.

Drinkers(name, addr, phone)

UPDATE Drinkers

SET phone = &#39;555-1212&#39;

WHERE name = &#39;Fred&#39;;

**Пример 2.**  За один просмотр таблицы установить максимальную цену для всех сортов пива в размере $4.

Sells(bar, beer, price)

UPDATESells

SETprice = 4.00

WHERE price &gt; 4.00;
