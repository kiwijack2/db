---
title: Реляционная модель.
---


Реляционная модель.

- .Таблица = отношение.
- .Названия столбцов = атрибуты.
- .Строка = кортеж

   Beers



name   manf

WinterBrew     Pete&#39;s

BudLite           A.B.

   …   …



- .Схема отношения = имена столбцов (атрибуты) + другая информация о структуре, например, ключи, другие ограничения.
Например: Beers (name, manf).
- .Порядок атрибутов произволен, но на практике используется порядок, указанный в схеме отношения.

- .Экземпляр отношения (таблица) – текущий набор строк для схемы отношения.

- .Схема базы данных = множество схем отношений.



Почему таблицы (отношения)?

- .Очень простая модель.
- .Часто совпадает с нашим представлением о данных.
- .Абстрактная модель, которая лежит в основе SQL, наиболее используемого сегодня языка в СУБД.

- .В абстрактной реляционной модели используется понятие «множество»,  а в SQL – «набор» или множество с повторениями.

Проектирование реляционной модели.

Самый простой подход (но не всегда лучший): преобразовать каждое множество сущностей и каждую связь в таблицу (отношение).

Множество сущностей  -&gt; Отношение

Атрибуты объекта станут реляционными атрибутами.





###### Beers



Преобразуется в : Beers (name, manf).

















E/R Связи -&gt; Oтношения.

Таблица имеет столбец для каждого атрибута-ключа множества сущностей,  участвующего в связи.

- .Добавить  атрибуты, которые принадлежат связи непосредственно.
- .Можно переименовать столбцы.
- .Существенно, для множественных ролей объектов.







###### Beers

###### Drinkers















husband                      wife





Likes (drinker, beer)

Favorite (drinker, beer)

Buddies (name1, name2)

Married (husband, wife)



Объединение таблиц (отношений).

Иногда это имеет смысл объединять отношения.

- .В общем случае: Отношение для некоторого объекта E плюс отношение для некоторой связи &quot;многие-к-одному&quot; объекта E и другого объекта.

Например:

Еслиобъединить Drinker (name, addr)  с

Favorite (drinker, beer), тополучим

Drinker1(name, addr, favBeer).

- .Объединение отношений может привести к избыточности.

- .Например, объединение Drinker  с  Likes приведет к дублированию addr, т.е.:



Name addr  beer

# Sally     123 Maple           Bud

Sally     123 Maple    Miller

- .Обратите внимание на отличие: Favorite – это связь &quot;многие-к-одному &quot;, а  Likes  - &quot;многие-ко-многим &quot;.











Слабые множества, Связи -&gt; Отношения.

- .Отношение для слабого объекта должно включать полный ключ (то есть, атрибуты связанных объектов) наряду с собственными атрибутами.

- .Такая поддерживающая связь (двойной ромб) производит отношение, которое является фактически избыточным и которое должно быть удалено из структуры базы данных

Например:





###### Hosts







Hosts (hostName)

Logins (loginName, hostName)

At (loginName, hostname, hostName2)



- .В отношении AthostName и hostName2 определяют один и тот же компьютер, поэтому можно удалить один из них.

- .Затем, отношения Logins и At становятся одинаковыми, поэтому можно удалить одно из них.

- .В этом случае, схема для Hosts – подмножество схемы для Logins. Удалить Hosts?





**Подклассы**** -&gt; ****Отношения.**

Подходы:



1. E/R модель: сущность распределена по набору классов, связанных посредством isa. Создается по одному отношению для каждой сущности.

- .Сущность представляется в отношениях  каждого подкласса,  которому она принадлежит.

- .Отношение имеет только присоединенные атрибуты объекта + ключ.

2. Использование NULL (пустых значений). Создается одно соотношение для корневого класса или корневого объекта, со всеми атрибутами, присутствующими в каком-либо подклассе.

- .Поместить NULL (пустое значение) в атрибутах, не относящихся к данному объекту.

Например:

###### Beers









###### Ales











E/R модель:



name   manf

Bud              A.B.

SummerBrew   Pete&#39;s

  Beers



name   color

SummerBrew          dark



       Ales

Использование Null (пустыхзначений):



name   manf  color

Bud                   A.B.           NULL

# SummerBrew           Pete&#39;s         dark



Beers

Функциональные зависимости.

X -&gt; A = утверждению относительно отношения R, если два кортежа имеют одинаковые значения атрибутов X, то они должны также иметь и одинаковые значения атрибута A.

Например:

Drinkers ( name, addr, beersLiked, manf, favoriteBeer)





name   addr     beersLiked  manf  favoriteBeer

Janeway    Voyager       Bud                      A.B.       WickedAle

Janeway    Voyager       WickedAle           Pete&#39;s     WickedAle

Spock        Enterprise    Bud                      A.B.        Bud

- .Можно утверждать, что:

1. name -&gt; addr

2. name -&gt; favoriteBeer

3. beersLiked -&gt; manf

- .Укороченная запись: объединение ФЗ с общей левой стороной объеденяет их правые стороны.
- .Иногда несколько атрибутов вместе определяют какой-нибудь атрибут, хотя каждый из них не делает этого.

Например: beer bar-&gt; price











Ключи отношений.

K - ключ для отношения R если:

1. K -&gt; все атрибуты R.

2. Не существует никакого строгого подмножества K, удовлетворяющего (1).

- .Если K по крайней мере удовлетворяет (1), то K – суперключ.



Соглашения.

- .Выбирается один ключ; атрибуты ключа подчеркиваются в схеме отношения.

- .Символом X,Y,Z и т.д. ,будем обозначать множества атрибутов; A,B,C и т.д.- отдельный атрибут.

- .ABC вместо {A, B, C} в ФЗ.



Пример.

Drinkers ( name, addr, beersLiked, manf, favoriteBeer)

- .{name,  beersLiked } -&gt; все остальные атрибуты.
- .{ name,  beersLiked } – суперключ.

- .name -&gt; beersLiked – не имеет места, поэтому name – не суперключ.
- .beersLiked -&gt; name – также не имеет места, поэтому предпочтения – не суперключ.
- .Т.о. { name,  beersLiked } – ключ.
- .Нет никакого другого ключа в этом примере.
- .Ни name ни beersLiked не могут находиться в правой стороне ФЗ, поэтому они являются частью любого суперключа.

- .Важно: понятие «ключ» связано с кортежем, а не с объектом.  Если объект представлен несколькими кортежами, то ключ объекта не то же самое, что ключ отношения.

Кто определяет ключи/функциональные зависимости?

- .Можно определить, что K - ключ.
- .Затем вывести функциональные зависимости – что

K -&gt; А для каждого атрибута A.

- .Не удивительно: K будет являться ключом, только если существуют такие ФЗ, согласно формальному определению ключа.

- .Или, можно установить некоторые ФЗ и определить один или  несколько ключей по формальным правилам.

- .Диаграмма «сущность-связь» определяет ФЗ путем указания ключей и связей «многие-к-одному».

- .Правило для руководства: любая ФЗ выводится из свойств ключа, связи «многие-к-одному» или здравого смысла .
- .Например, &quot;Нет двух предметов, которые проводятся в одной и той же аудитории в одно и то же  время &quot;  влечет

аудитория время -&gt; предмет.



Вывод функциональных зависимостей.

Это важно потому что...

- .Если мы пытаемся  улучшить реляционную модель данных, то часто задаемся вопросом &quot;Должна ли эта ФЗ присутствовать в этом отношении? &quot;

Если существуют ФЗ Х1 -&gt; A1, X2 -&gt; A2, … Xn -&gt; An, будет ли необходимо выполняться ФЗ Y -&gt; B  в том же самом отношении?

- .Начнем с предположения, что 2 кортежа имеют одинаковое значение Y. Используем данные ФЗ чтобы вывести другие атрибуты с одинаковыми значениямию. Если  B  среди них то имеет место Y -&gt; B .



Алгоритм.

Пусть Y+= замыкание Y = множество атрибутов функционально зависимых от Y :

- .Первоначально: Y+:= Y .
- .Индукция: Если X  Y+ и  X -&gt; A – функциональная зависимость, то A добавляется к Y+.











- .Конец, если Y+ не изменяется.



**Пример****.**



A -&gt; B, BC -&gt; D.

- .A+= AB.

- .C+= C.

- .(AC)+= ABCD.





Нахождение всех возможных функциональных зависимостей.

Зачем это делается: Предположим, что есть отношение ABCD с некоторой функциональной зависимостью F. Если мы решаем разбить ABCD на ABC и AD, что будет ФЗ для ABC и AD?

- .Например: F = AB -&gt; C, C -&gt; D, D -&gt; A.

Подходит только AB  -&gt; C  для ABC, но фактически C -&gt; A следует из F и может быть применено к отношению ABC.

- .Сложность задачи растет экспоненциально с ростом числа атрибутов.

Алгоритм.

- .Для каждого множества атрибутов Х определить Х+.

- .Исключая Х= и Х=все атрибуты.

- .Добавить X -&gt; A для каждого A  из  X+ - X.

- .Удалить XY -&gt; A, если есть X -&gt; A.

- .Спроектировать ФЗ – выбрать те ФЗ, которые включают только атрибуты проекции.

- .Обратите внимание, что после того, как мы спроектируем ФЗ на некоторое отношение, удаленные ФЗ могут быть выведены из этого отношения.

**Пример****.**

Для отношения ABC  с ФЗ: A -&gt; B, B -&gt; C, спроектировать ФЗ  на AC.

1. A+= ABC;  дает A -&gt; B, A -&gt; C.

2. B+= BC;  дает  B -&gt; C.

3. AB+= ABC; дает AB -&gt; C; опускаем в пользу A -&gt; C.

4. AC+= ABC дает AC -&gt; B; опускаем в пользу  A -&gt; B.

5. C+= C  и  BC+= BC;  ничего не добавляет.

- .В результате имеем  FD&#39;s: A -&gt; B, A -&gt; C, B -&gt; C.

- .Проекция на AC: A -&gt; C.
